import torch
import torchvision
from torchvision import transforms
import os
import numpy as np
from PIL import Image


def load_model():
    """–ó–∞–≥—Ä—É–∂–∞–µ—Ç –æ–±—É—á–µ–Ω–Ω—É—é ResNet50 –º–æ–¥–µ–ª—å –¥–ª—è –∏–Ω—Ñ–µ—Ä–µ–Ω—Å–∞"""
    device = torch.device("cuda" if torch.cuda.is_available() else "cpu")
    print(f"üöÄ Using device: {device}")

    # –ó–∞–≥—Ä—É–∑–∫–∞ –∞—Ä—Ö–∏—Ç–µ–∫—Ç—É—Ä—ã ResNet50
    model = torchvision.models.resnet50(weights=None)

    # –ó–∞–≥—Ä—É–∑–∫–∞ –ø—Ä–µ–¥–æ–±—É—á–µ–Ω–Ω—ã—Ö –≤–µ—Å–æ–≤ –¥–ª—è –±–∞–∑–æ–≤–æ–π –∞—Ä—Ö–∏—Ç–µ–∫—Ç—É—Ä—ã
    base_weights_path = "models/resnet50_weights/resnet50-11ad3fa6.pth"
    if os.path.exists(base_weights_path):
        print(f"‚úÖ Loading base weights from: {base_weights_path}")
        base_weights = torch.load(base_weights_path, map_location=device)
        model.load_state_dict(base_weights, strict=False)

    # –ó–∞–º–µ–Ω–∞ –∫–ª–∞—Å—Å–∏—Ñ–∏–∫–∞—Ç–æ—Ä–∞ –Ω–∞ –æ–±—É—á–µ–Ω–Ω—ã–π
    num_classes = 15  # –í–∞—à–µ –∫–æ–ª–∏—á–µ—Å—Ç–≤–æ –∫–ª–∞—Å—Å–æ–≤
    num_ftrs = model.fc.in_features
    model.fc = torch.nn.Sequential(
        torch.nn.Linear(num_ftrs, 1024),
        torch.nn.ReLU(),
        torch.nn.Dropout(0.5),
        torch.nn.Linear(1024, 512),
        torch.nn.ReLU(),
        torch.nn.Dropout(0.3),
        torch.nn.Linear(512, num_classes)
    )

    # –ó–∞–≥—Ä—É–∑–∫–∞ –æ–±—É—á–µ–Ω–Ω—ã—Ö –≤–µ—Å–æ–≤ –º–æ–¥–µ–ª–∏
    model_path = "models/plant_disease_resnet50_best.pth"
    if not os.path.exists(model_path):
        raise FileNotFoundError(f"Model file not found at {model_path}")

    print(f"üîÑ Loading trained model weights from: {model_path}")
    state_dict = torch.load(model_path, map_location=device)
    model.load_state_dict(state_dict)

    # –ü–µ—Ä–µ–º–µ—â–µ–Ω–∏–µ –Ω–∞ GPU –∏ —É—Å—Ç–∞–Ω–æ–≤–∫–∞ –≤ eval —Ä–µ–∂–∏–º
    model = model.to(device)
    model.eval()

    print("‚úÖ Model loaded and ready for inference!")
    return model


def get_transforms():
    """–í–æ–∑–≤—Ä–∞—â–∞–µ—Ç –ø—Ä–µ–æ–±—Ä–∞–∑–æ–≤–∞–Ω–∏—è –¥–ª—è –∏–∑–æ–±—Ä–∞–∂–µ–Ω–∏–π"""
    return transforms.Compose([
        transforms.Resize(256),
        transforms.CenterCrop(224),
        transforms.ToTensor(),
        transforms.Normalize(mean=[0.485, 0.456, 0.406], std=[0.229, 0.224, 0.225])
    ])


def predict_disease(model, image_path):
    """–í—ã–ø–æ–ª–Ω—è–µ—Ç –ø—Ä–µ–¥—Å–∫–∞–∑–∞–Ω–∏–µ –±–æ–ª–µ–∑–Ω–∏ –Ω–∞ –∏–∑–æ–±—Ä–∞–∂–µ–Ω–∏–∏ —Ä–∞—Å—Ç–µ–Ω–∏—è"""
    device = next(model.parameters()).device

    try:
        # –ó–∞–≥—Ä—É–∑–∫–∞ –∏ –ø—Ä–µ–æ–±—Ä–∞–∑–æ–≤–∞–Ω–∏–µ –∏–∑–æ–±—Ä–∞–∂–µ–Ω–∏—è
        img = Image.open(image_path).convert('RGB')
        transform = get_transforms()
        img_tensor = transform(img).unsqueeze(0).to(device)

        # –ü—Ä–µ–¥—Å–∫–∞–∑–∞–Ω–∏–µ
        with torch.no_grad():
            output = model(img_tensor)
            probabilities = torch.nn.functional.softmax(output, dim=1)
            confidence, predicted_idx = torch.max(probabilities, 1)

        # –ü–æ–ª—É—á–µ–Ω–∏–µ –Ω–∞–∑–≤–∞–Ω–∏—è –∫–ª–∞—Å—Å–∞
        class_names = [
            'Pepper__bell___Bacterial_spot', 'Pepper__bell___healthy', 'Potato___Early_blight',
            'Potato___Late_blight', 'Potato___healthy', 'Tomato_Bacterial_spot',
            'Tomato_Early_blight', 'Tomato_Late_blight', 'Tomato_Leaf_Mold',
            'Tomato_Septoria_leaf_spot', 'Tomato_Spider_mites_Two_spotted_spider_mite',
            'Tomato__Target_Spot', 'Tomato__Tomato_YellowLeaf__Curl_Virus',
            'Tomato__Tomato_mosaic_virus', 'Tomato_healthy'
        ]

        predicted_class = class_names[predicted_idx.item()]
        confidence_value = confidence.item() * 100

        # –§–æ—Ä–º–∞—Ç–∏—Ä–æ–≤–∞–Ω–∏–µ –Ω–∞–∑–≤–∞–Ω–∏—è –¥–ª—è –æ—Ç–æ–±—Ä–∞–∂–µ–Ω–∏—è
        display_name = predicted_class.replace('__', ' - ').replace('_', ' ').replace(' -  ', ' - ')

        return {
            'class': predicted_class,
            'display_name': display_name,
            'confidence': confidence_value,
            'probabilities': probabilities.cpu().numpy()[0].tolist(),
            'all_classes': class_names
        }

    except Exception as e:
        return {'error': str(e)}